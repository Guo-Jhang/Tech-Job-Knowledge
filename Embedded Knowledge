======================================================================
mutex lock semaphore
Binary semaphore與Mutex的差異：
在有的系統中Binary semaphore與Mutex是沒有差異的。在有的系統上，主要的差異是mutex一定要由獲得鎖的進程來釋放。而semaphore可以由其它進程釋放（這時的semaphore實際就是個原子的變量，大家可以加或減），因此semaphore可以用於進程間同步。 Semaphore的同步功能是所有系統都支持的，而Mutex能否由其他進程釋放則未定，因此建議mutex只用於保護critical section。而semaphore則用於保護某變量，或者同步。
同步:initial:0
保護:initial:1
race condition
競爭危害
電腦的兩個行程都試圖修改一個共享記憶體的內容。在沒有並行控制的情況下，最後的結果依賴於兩個行程的執行順序與時機，特別是如果發生了並行存取衝突，則最後的結果是不正確的。


==================================
ANDROID CLASS
注意到public這個關鍵字，它表示以下所定義的成員可以使 用物件名稱直接被呼叫，也稱之為「公用成員」或「公開成員」，private關鍵字下的則是「私用成員」或「私有成員」，不可以透過物件名稱直接呼叫。


user mode、kernel mode 的差別？trap 是什麼？簡單解釋 system call 流程。
Kernel mode權限較大，可以任意存取週邊設備。
User mode 則是會有受限，應用程式都是在user mode執行
Trap是軟體中斷。
呼叫SYSTEM CALL=>傳參數給ISR=>OS執行軟體中斷(trap)將user mode切換成kernel mode，OS經由傳入的參數呼叫對應的ISR，執行ISR=>完成後回到user mode。
==================================
__interrupt double isr(double r)
      {
         double area = PI*r*r ;
         printf("%f\n",area) ;
         return area ;
      }
      說明並解釋上述之interrupt service routine 之錯誤處？
1、	ISR不能有返回值；
2、ISR不能傳遞參數；
3、ISR應該是短而高效的，在ISR中做浮點運算是不明智的；
4、ISR中不應該有重入和性能上的問題，因此不應該使用pintf()函數。
==================================
何謂deadlock?
1.	Mutual exclusion(互斥)
Def：
資源在同一時間內，至多只允許一個process使用(不允許≥2個processes同時使用)
其它欲使用此resource的process必須wait，直到該process釋放resource為止
eg. printer、Disk、CPU etc.
eg. 不具mutual exclusion→Read-only File
2.	Hold & wait(持有並等待) (Partial Allocation)
Def：
process持有部分資源且又在等待其它processes所持有的資源
3.	No preemption(不可強取豪奪)
Def：
process不可搶奪其它waiting process所持有的資源，除非其自願釋放
4.	Circular waiting(循環等待)
Def：
存在一組process
P0→P1→P2→...→Pn→P0
P0~Pn形成Circular waiting
打破四個必要條件之其一，就可保證死結永不發生
打破"Hold&Wait"
作法：OS可採取下列二個協定之一即可
協定一
除非process可以一次取得完成工作所需的全部資源，才允許process持有資源，否則不准持有任何資源
協定二
允許process在執行之初可先持有部分資源，一旦要申請新資源，則必須先釋放持有的全部資源，才可以提申請
打破"No Preemption"
作法：改為preemption即可
process可以搶奪waiting process所持有的Resource
Note：死結不會發生。但有可能產生starvation
解決：採取類似"Aging"技術(將被搶奪的次數，列為提高優先權之依據)
============================================
判斷是big endian or little endian
int main() {
    unsigned int i = 1;
    char *c = (char*)&i;
    if (*c)    
        printf("Little endian\n");
    else
        printf("Big endian\n");
 
    return 0;
}
============================================
Big endian & little endian swap
unsigned uint32_t swap_uint32( uint32_t val )
{
    val = ((val << 8) & 0xFF00FF00 ) | ((val >> 8) & 0xFF00FF ); 
    return (val << 16) | (val >> 16);
}

