======================================================================
mutex lock semaphore
Binary semaphore與Mutex的差異：
在有的系統中Binary semaphore與Mutex是沒有差異的。在有的系統上，主要的差異是mutex一定要由獲得鎖的進程來釋放。而semaphore可以由其它進程釋放（這時的semaphore實際就是個原子的變量，大家可以加或減），因此semaphore可以用於進程間同步。 Semaphore的同步功能是所有系統都支持的，而Mutex能否由其他進程釋放則未定，因此建議mutex只用於保護critical section。而semaphore則用於保護某變量，或者同步。
同步:initial:0
保護:initial:1
race condition
競爭危害
電腦的兩個行程都試圖修改一個共享記憶體的內容。在沒有並行控制的情況下，最後的結果依賴於兩個行程的執行順序與時機，特別是如果發生了並行存取衝突，則最後的結果是不正確的。


==================================
ANDROID CLASS
注意到public這個關鍵字，它表示以下所定義的成員可以使 用物件名稱直接被呼叫，也稱之為「公用成員」或「公開成員」，private關鍵字下的則是「私用成員」或「私有成員」，不可以透過物件名稱直接呼叫。


user mode、kernel mode 的差別？trap 是什麼？簡單解釋 system call 流程。
Kernel mode權限較大，可以任意存取週邊設備。
User mode 則是會有受限，應用程式都是在user mode執行
Trap是軟體中斷。
呼叫SYSTEM CALL=>傳參數給ISR=>OS執行軟體中斷(trap)將user mode切換成kernel mode，OS經由傳入的參數呼叫對應的ISR，執行ISR=>完成後回到user mode。
==================================
__interrupt double isr(double r)
      {
         double area = PI*r*r ;
         printf("%f\n",area) ;
         return area ;
      }
      說明並解釋上述之interrupt service routine 之錯誤處？
1、	ISR不能有返回值；
2、ISR不能傳遞參數；
3、ISR應該是短而高效的，在ISR中做浮點運算是不明智的；
4、ISR中不應該有重入和性能上的問題，因此不應該使用pintf()函數。
==================================
何謂deadlock?
1.	Mutual exclusion(互斥)
Def：
資源在同一時間內，至多只允許一個process使用(不允許≥2個processes同時使用)
其它欲使用此resource的process必須wait，直到該process釋放resource為止
eg. printer、Disk、CPU etc.
eg. 不具mutual exclusion→Read-only File
2.	Hold & wait(持有並等待) (Partial Allocation)
Def：
process持有部分資源且又在等待其它processes所持有的資源
3.	No preemption(不可強取豪奪)
Def：
process不可搶奪其它waiting process所持有的資源，除非其自願釋放
4.	Circular waiting(循環等待)
Def：
存在一組process
P0→P1→P2→...→Pn→P0
P0~Pn形成Circular waiting
打破四個必要條件之其一，就可保證死結永不發生
打破"Hold&Wait"
作法：OS可採取下列二個協定之一即可
協定一
除非process可以一次取得完成工作所需的全部資源，才允許process持有資源，否則不准持有任何資源
協定二
允許process在執行之初可先持有部分資源，一旦要申請新資源，則必須先釋放持有的全部資源，才可以提申請
打破"No Preemption"
作法：改為preemption即可
process可以搶奪waiting process所持有的Resource
Note：死結不會發生。但有可能產生starvation
解決：採取類似"Aging"技術(將被搶奪的次數，列為提高優先權之依據)
============================================
判斷是big endian or little endian
int main() {
    unsigned int i = 1;
    char *c = (char*)&i;
    if (*c)    
        printf("Little endian\n");
    else
        printf("Big endian\n");
 
    return 0;
}
============================================
Big endian & little endian swap
unsigned uint32_t swap_uint32( uint32_t val )
{
    val = ((val << 8) & 0xFF00FF00 ) | ((val >> 8) & 0xFF00FF ); 
    return (val << 16) | (val >> 16);
}
===================================================
DMA
DMA是所有現代電腦的重要特色，他允許不同速度的硬體裝置來溝通，而不需要依於中央處理器的大量中斷負載。否則，中央處理器需要從來源把每一片段的資料複製到暫存器，然後把他們再次寫回到新的地方。在這個時間中，中央處理器對於其他的工作來說就無法使用。
DMA傳輸常使用在將一個記憶體區從一個裝置複製到另外一個。當中央處理器初始化這個傳輸動作，傳輸動作本身是由DMA控制器來實行和完成。典型的例子就是移動一個外部記憶體的區塊到晶片內部更快的記憶體去。像是這樣的操作並沒有讓處理器工作拖延，使其可以被重新排程去處理其他的工作。DMA傳輸對於高效能嵌入式系統演算法和網路是很重要的。
===============================================
uClinux 與 Linux 最大差異在哪？
uClinux沒有MMU管理存儲器，其對內存的訪問是直接的，所有程序中訪問的地址都是實際的物理地址。操作系統對內存空間沒有保護，各個進程實際上共享一個運行空間。這就需要實現多進程時進行數據保護，也導致了用戶程序使用的空間可能佔用到系統內核空間。這些問題在編程時都需要多加注意，否則容易導致系統崩潰。
記憶體管理單元（英語：memory management unit，縮寫為MMU），有時稱作分頁記憶體管理單元（英語：paged memory management unit，縮寫為PMMU）。它是一種負責處理中央處理器（CPU）的記憶體存取請求的電腦硬體。它的功能包括虛擬位址到實體位址的轉換（即虛擬記憶體管理）、記憶體保護、中央處理器快取的控制，在較為簡單的電腦體系結構中，負責匯流排的仲裁以及儲存體切換（bank switching，尤其是在8位元的系統上）。
===============================================
列舉幾個serial port, parallel port
序列埠(serial port)、平行埠(parallel port)
Serial port : RS232、示波器
parallel port: 印表機、LPT
===============================================
如何 Linux 與 windows 互相傳送檔案？
ftp、網路空間、samba。
PS:samba:可以讓linux跟windows形同運作”網路上的芳鄰”一樣存取檔案
==================================================
